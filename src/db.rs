use crate::schema::{invites, ntfy_users, tg_users, uptime_states, users};
use rand::{Rng, distributions::Alphanumeric};
use rocket::serde::{Deserialize, Serialize};
use rocket_db_pools::diesel::AsyncPgConnection;
use rocket_db_pools::diesel::prelude::*;
use rocket_db_pools::diesel::scoped_futures::ScopedFutureExt;
use std::time::SystemTime;
use uuid::Uuid;

pub type ID = Uuid;
type R<T> = std::result::Result<T, Box<dyn std::error::Error>>;

#[derive(Debug)]
enum CustomError {
    DieselError(diesel::result::Error),
    CreationFailed,
}

impl From<diesel::result::Error> for CustomError {
    fn from(e: diesel::result::Error) -> Self {
        CustomError::DieselError(e)
    }
}

/// Ntfy.sh instance 'managed' user for whoever is using the service,
/// which is created with read-only permissions for their own topic.
/// A lot of this information is provided to the user and can be reset
/// by the user at any point (not for 'tier' or 'permission' obviously).
#[derive(Debug, Clone, Serialize, Queryable, Selectable, Insertable)]
#[diesel(table_name = ntfy_users)]
#[serde(crate = "rocket::serde")]
pub struct NtfyUser {
    pub id: ID,
    #[serde(skip_serializing)]
    pub enabled: bool,
    pub topic: String,
    #[serde(rename(serialize = "permission"))]
    pub topic_permission: String,
    pub username: String,
    pub password: String,
    pub tier: String,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Serialize, diesel_derive_enum::DbEnum)]
#[ExistingTypePath = "crate::schema::sql_types::ChatStateEnum"]
#[serde(crate = "rocket::serde")]
pub enum ChatState {
    Main,
    Invites,
}

#[derive(Debug, Clone, Serialize, Queryable, Selectable, Insertable)]
#[diesel(table_name = tg_users)]
#[serde(crate = "rocket::serde")]
pub struct TelegramUser {
    pub id: ID,
    pub enabled: bool,
    pub user_id: i64,
    pub chat_id: Option<i64>, // Telegram chat or channel id for posting status.
    pub chat_state: ChatState,
    // @TODO: We should check on every message and update in db if changed.
    pub language_code: String,
}

impl TelegramUser {
    pub fn new(enabled: bool, user_id: i64, language_code: String) -> TelegramUser {
        return TelegramUser {
            id: Uuid::new_v4(),
            enabled,
            user_id,
            chat_id: None,
            chat_state: ChatState::Main,
            language_code,
        };
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Deserialize, Serialize, diesel_derive_enum::DbEnum)]
#[ExistingTypePath = "crate::schema::sql_types::UserTypeEnum"]
#[serde(crate = "rocket::serde")]
pub enum UserType {
    Normal,
    Admin,
}

#[derive(Debug, Clone, Serialize, Queryable, Selectable, Insertable)]
#[diesel(table_name = users)]
#[serde(crate = "rocket::serde")]
pub struct User {
    pub id: ID,
    pub user_type: UserType,
    pub created_at: SystemTime,
    pub invites_limit: i64,
    pub invites_used: i64,
    pub access_token: String,
    pub up_delay: i16,
    pub down_delay: i16, // @nocheckin: actually implement? feels implemented
    pub ntfy_id: ID,
    pub tg_id: ID,
}

impl User {
    pub fn new(
        user_type: UserType,
        invites_limit: i64,
        up_delay: Option<u16>,
        down_delay: Option<u16>,
        ntfy: &NtfyUser,
        tg: &TelegramUser,
    ) -> User {
        let rng = rand::thread_rng();
        let secret_part: String = rng.sample_iter(&Alphanumeric).take(32).map(char::from).collect();
        User {
            id: Uuid::new_v4(),
            user_type,
            created_at: SystemTime::now(),
            invites_limit,
            invites_used: 0,
            access_token: format!("tk_{secret_part}"),
            // @nocheckin: assert this value has to be above 10 seconds.
            up_delay: up_delay.unwrap_or(30) as i16,
            down_delay: down_delay.unwrap_or(0) as i16,
            ntfy_id: ntfy.id,
            tg_id: tg.id,
        }
    }
}

// @NOTE: This is the the second out of 2 diesel enum packages that I've tried,
//  and the first one is even more broken. This one works as long as you go into
//  the src/schema.rs file and remove autogenerated trair 'Clone' from there. I
//  found some conversation and question about this being asked, but they both
//  were marked as "resolved" so I'm not sure if I'm doing something wrong, or
//  if this issue will come back in the future after every migration run. Here
//  are the links:
//    - https://github.com/adwhit/diesel-derive-enum/issues/91
//    - https://github.com/adwhit/diesel-derive-enum/issues/10
//  This was written at 4:44 am and I refuse to spent any more time on fixing
//  this hack. I do not understand why the fu*ck is this feature not in diesel
//  standard library.                                       - andrew, Nov 2 2024
#[derive(Debug, Copy, Clone, Eq, PartialEq, diesel_derive_enum::DbEnum)]
#[ExistingTypePath = "crate::schema::sql_types::StatusEnum"]
pub enum UpStatus {
    Uninitialized,
    Up,
    Down,
    Maintainance,
}

#[derive(Debug, Clone, Queryable, Selectable, Insertable)]
#[diesel(table_name = uptime_states)]
pub struct UptimeState {
    pub id: ID,
    pub created_at: SystemTime,
    pub touched_at: SystemTime,
    pub status: UpStatus,
    pub user_id: Option<ID>,
    pub state_changed_at: SystemTime,
}

impl UptimeState {
    pub fn new(user_id: ID) -> UptimeState {
        let now = SystemTime::now();
        UptimeState {
            id: Uuid::new_v4(),
            created_at: now,
            touched_at: now,
            status: UpStatus::Uninitialized,
            user_id: Some(user_id),
            state_changed_at: now,
        }
    }

    /// Called when device pings. Returns Some(duration) if state changed from Down to Up,
    /// where duration is the time power was off.
    pub fn touch(&mut self) -> Option<std::time::Duration> {
        let now = SystemTime::now();
        self.touched_at = now;

        if self.status == UpStatus::Uninitialized {
            self.status = UpStatus::Up;
            self.state_changed_at = now;
            return None;
        }

        if self.status == UpStatus::Down {
            // Calculate how long power was off (since last state change to Down)
            let duration = now.duration_since(self.state_changed_at).ok();
            self.status = UpStatus::Up;
            self.state_changed_at = now;
            return duration;
        }
        return None;
    }

    /// Called when timeout expires. Returns Some(duration) if state changed from Up to Down,
    /// where duration is the time power was on.
    pub fn go_down(&mut self) -> Option<std::time::Duration> {
        if self.status == UpStatus::Up {
            let now = SystemTime::now();
            // Calculate how long power was on (since last state change to Up)
            let duration = now.duration_since(self.state_changed_at).ok();
            self.status = UpStatus::Down;
            self.state_changed_at = now;
            return duration;
        }
        return None;
    }
}

#[derive(Debug, Clone, Serialize)]
#[serde(crate = "rocket::serde")]
pub struct UserState {
    pub user: User,
    pub ntfy: NtfyUser,
    pub tg: TelegramUser,
    #[serde(skip_serializing)]
    pub uptime: UptimeState,
}

pub async fn create_new_state(
    conn: &mut AsyncPgConnection,
    user_state: &UserState,
    token_id: Option<&Uuid>,
) -> Result<(), String> {
    // @TODO: We do a bunch of create operations that need to be a single
    //  transaction to have automatic roll back in case any of them fails.
    let result = conn
        .transaction::<_, CustomError, _>(|tconn| {
            async move {
                // @nocheckin: If token provided, verify it and throw if missing or already taken.
                // @nocheckin: Instead of provided invites_limit 5, take it from the previous user.
                // @nocheckin: Update invite body to specify if invite is for admins (make sure
                //         normal user cannot make an invite of the level above them, future proof).
                diesel::insert_into(ntfy_users::dsl::ntfy_users)
                    .values(&user_state.ntfy)
                    .returning(ntfy_users::dsl::id)
                    .get_result::<ID>(tconn)
                    .await?;
                diesel::insert_into(tg_users::dsl::tg_users)
                    .values(&user_state.tg)
                    .returning(tg_users::dsl::id)
                    .get_result::<ID>(tconn)
                    .await?;
                diesel::insert_into(users::dsl::users)
                    .values(&user_state.user)
                    .returning(users::dsl::id)
                    .get_result::<ID>(tconn)
                    .await?;
                diesel::insert_into(uptime_states::dsl::uptime_states)
                    .values(&user_state.uptime)
                    .returning(uptime_states::dsl::id)
                    .get_result::<ID>(tconn)
                    .await?;
                Ok(())
            }
            .scope_boxed()
        })
        .await;

    // @nocheckin: this is so ugly
    match result {
        Ok(_) => Ok(()),
        Err(err) => Err(format!("{err:?}")),
    }
}

pub async fn get_all_states(conn: &mut AsyncPgConnection) -> R<Vec<UserState>> {
    let user_items: Vec<(User, NtfyUser, TelegramUser)> = users::dsl::users
        .inner_join(ntfy_users::dsl::ntfy_users)
        .inner_join(tg_users::dsl::tg_users)
        .select((User::as_select(), NtfyUser::as_select(), TelegramUser::as_select()))
        .load::<(User, NtfyUser, TelegramUser)>(conn)
        .await?;

    let mut all_states = Vec::new();
    for (user, ntfy, tg) in user_items {
        let uptime = uptime_states::dsl::uptime_states
            .filter(uptime_states::dsl::user_id.eq(user.id))
            .order(uptime_states::dsl::created_at.desc())
            .select(UptimeState::as_select())
            .first::<UptimeState>(conn)
            .await?;
        all_states.push(UserState { user, ntfy, tg, uptime });
    }

    Ok(all_states)
}

#[derive(Debug, Clone, Serialize, Queryable, Selectable, Insertable)]
#[diesel(table_name = invites)]
#[serde(crate = "rocket::serde")]
pub struct Invite {
    pub id: ID,
    pub created_at: SystemTime,
    pub token: String,
    pub is_used: bool,
    pub owner_id: ID,
    pub user_id: Option<ID>,
}

impl Invite {
    // @TODO: Move invited user perms level here?
    pub fn new(owner_id: ID) -> Invite {
        let rng = rand::thread_rng();
        Invite {
            id: Uuid::new_v4(),
            created_at: SystemTime::now(),
            token: rng.sample_iter(&Alphanumeric).take(24).map(char::from).collect(),
            is_used: false,
            owner_id,
            user_id: None,
        }
    }
}

pub async fn create_new_invite(conn: &mut AsyncPgConnection, invite: &Invite) -> Result<(), String> {
    let result = conn
        .transaction::<_, CustomError, _>(|tconn| {
            async move {
                // diesel::update(invites::dsl::invites).set(invites::dsl::invites::);
                let (limit, used) = diesel::update(users::dsl::users)
                    .filter(users::dsl::id.eq(invite.owner_id))
                    .set(users::dsl::invites_used.eq(users::dsl::invites_used + 1))
                    .returning((users::dsl::invites_limit, users::dsl::invites_used))
                    .get_result::<(i64, i64)>(tconn)
                    .await?;

                // Abort operation if limit was passed.
                if used >= limit {
                    warn!("New invite failed: {used}/{limit} for uid {}!", invite.owner_id);
                    return Err(CustomError::CreationFailed);
                }

                diesel::insert_into(invites::dsl::invites)
                    .values(invite)
                    .returning(invites::dsl::id)
                    .get_result::<ID>(tconn)
                    .await?;

                Ok(())
            }
            .scope_boxed()
        })
        .await;

    // @nocheckin: this is so ugly
    match result {
        Ok(_) => Ok(()),
        Err(err) => Err(format!("{err:?}")),
    }
}
